// Danger! Danger! Metaprogramming bullshit ahead.

import path from 'path';
import globby from 'globby';

// Wraps one or more GraphQL query specs loaded from code generated by relay-compiler. These are the files with
// names matching `**/__generated__/*.graphql.js` that are created when you run "npm run relay".
class Spec {

  // Normalize an Array of "node" objects imported from *.graphql.js files. Wrap them in a Spec instance to take
  // advantage of query methods.
  constructor(nodes, typeName, registry) {
    const gettersByKind = {
      Fragment: node => node,
      LinkedField: node => node,
      Request: node => node.fragment,
    };

    this.nodes = nodes.map(node => {
      const fn = gettersByKind[node.kind];
      if (fn === undefined) {
        /* eslint-disable-next-line */
        console.error(
          `Unrecognized node kind "${node.kind}".\n` +
          "I couldn't figure out what to do with a parsed GraphQL module.\n" +
          "Either you're passing something unexpected into an xyzBuilder() method,\n" +
          'or the Relay compiler is generating something that our builder factory\n' +
          "doesn't yet know how to handle.",
          node,
        );
        throw new Error(`Unrecognized node kind ${node.kind}`);
      } else {
        return fn(node);
      }
    });

    // Discover and (recursively) flatten any fragment spreads in-place.
    const flattenFragments = selections => {
      const spreads = new Map();
      for (let i = selections.length - 1; i >= 0; i--) {
        if (selections[i].kind === 'InlineFragment') {
          // Replace inline fragments in-place with their selected fields *if* the GraphQL type name matches.

          if (selections[i].type !== typeName) {
            continue;
          }
          spreads.set(i, selections[i].selections);
        } else if (selections[i].kind === 'FragmentSpread') {
          // Replace named fragments in-place with their selected fields if a non-null SpecRegistry is available and
          // the GraphQL type name matches.

          const fragmentNode = registry.withName(selections[i].name);
          if (fragmentNode === null) {
            continue;
          }
          if (fragmentNode.type !== typeName) {
            continue;
          }

          spreads.set(i, fragmentNode.selections);
        }
      }

      for (const [index, subSelections] of spreads) {
        flattenFragments(subSelections);
        selections.splice(index, 1, ...subSelections);
      }
    };

    for (const node of this.nodes) {
      flattenFragments(node.selections);
    }
  }

  // Query all of our query specs for the names of selected fields that match a certain "kind". Field kinds include
  // ScalarField, LinkedField, FragmentSpread, and likely others. Field aliases are preferred over field names if
  // present. Fields that are duplicated across query specs (which could happen when multiple query specs are
  // provided) will be returned once.
  getRequestedFields(kind) {
    const fieldNames = new Set();
    for (const node of this.nodes) {
      for (const selection of node.selections) {
        if (selection.kind === kind) {
          fieldNames.add(selection.alias || selection.name);
        }
      }
    }
    return Array.from(fieldNames);
  }

  // Return the names of all known scalar (Int, String, and so forth) fields selected by current queries.
  getRequestedScalarFields() {
    return this.getRequestedFields('ScalarField');
  }

  // Return the names of all known linked (composite with sub-field) fields selected by current queries.
  getRequestedLinkedFields() {
    return this.getRequestedFields('LinkedField');
  }

  // Return one or more subqueries that describe fields selected within a linked field called "name". If no such
  // subqueries may be found, an error is thrown.
  getLinkedNodes(name) {
    const subNodes = [];
    for (const node of this.nodes) {
      const match = node.selections.find(selection => selection.alias === name || selection.name === name);
      if (match) {
        subNodes.push(match);
      }
    }
    if (subNodes.length === 0) {
      throw new Error(`Unable to find linked field ${name}`);
    }
    return subNodes;
  }
}

// Discover and load all fragment modules in the package, indexed by name.
class SpecRegistry {
  constructor() {
    this.fragmentsByName = new Map();
    this.hasStarted = false;
    this.populatingPromise = new Promise(resolve => {
      this.resolvePopulatingPromise = resolve;
    });
  }

  // Load all *.graphql.js files into a map by name.
  async populate() {
    this.hasStarted = true;
    const root = path.resolve(__dirname, '../../..');

    const allModulePaths = await globby(['**/__generated__/*.graphql.js'], {
      cwd: root,
      gitignore: true,
      absolute: true,
    });

    for (const modulePath of allModulePaths) {
      const node = require(modulePath);
      if (node.kind === 'Fragment') {
        this.fragmentsByName.set(node.name, node);
      }
    }

    this.resolvePopulatingPromise();
  }

  // Ensure that populate() has run at most once.
  ensurePopulated() {
    if (!this.hasStarted) {
      return this.populate();
    } else {
      return this.populatingPromise;
    }
  }

  // Access a referenced fragment by name. Throw an error if the name is not known.
  withName(name) {
    const node = this.fragmentsByName.get(name);
    if (node === undefined) {
      throw new Error(`Unable to find referenced fragment with name "${name}"`);
    }
    return node;
  }
}

// Default implementation for a SpecRegistry that is (intentionally) empty.
const nullSpecRegistry = {
  withName() {
    return null;
  },
};

// Private symbol used to identify what fields within a Builder have been populated (by a default setter or an
// explicit setter call). Using this instead of "undefined" lets us actually have "null" or "undefined" values
// if we want them.
const UNSET = Symbol('unset');

// How many times has this exact helper been written?
function capitalize(word) {
  return word[0].toUpperCase() + word.slice(1);
}

// Format the name of the method used to generate a default value for a field if one is not explicitly provided. For
// example, a fieldName of "someThing" would be "getDefaultSomeThing()".
function makeDefaultGetterName(fieldName) {
  return `getDefault${capitalize(fieldName)}`;
}

// Format the name of a method used to append a value to the end of a collection. For example, a fieldName of
// "someThing" would be "addSomeThing()".
function makeAdderFunctionName(fieldName) {
  return `add${capitalize(fieldName)}`;
}

// Format the name of a method used to mark a field as explicitly null and prevent it from being filled out with
// default values. For example, a fieldName of "someThing" would be "nullSomeThing()".
function makeNullableFunctionName(fieldName) {
  return `null${capitalize(fieldName)}`;
}

// Superclass for Builders that are expected to adhere to the fields requested by a GraphQL fragment.
class SpecBuilder {

  // Compatibility with deferred-resolution builders.
  static resolve() {
    return this;
  }

  // Construct a SpecBuilder that builds an instance corresponding to a single GraphQL schema type, including only
  // the fields selected by "nodes".
  constructor(nodes, options = {}) {
    this.options = {
      specRegistry: nullSpecRegistry,
      ...options,
    };

    if (!nodes || nodes.length === 0) {
      /* eslint-disable-next-line no-console */
      console.error(
        `No parsed queries given to ${this.builderName}.\n` +
        "Make sure you're passing a compiled Relay query (__generated__/*.graphql.js module)" +
        ' to the builder construction function.',
      );
      throw new Error(`No parsed queries given to ${this.builderName}`);
    }

    this.spec = new Spec(nodes, this.typeName, this.options.specRegistry);

    this.knownScalarFieldNames = new Set(this.spec.getRequestedScalarFields());
    this.knownLinkedFieldNames = new Set(this.spec.getRequestedLinkedFields());

    this.fields = {};
    for (const fieldName of [...this.knownScalarFieldNames, ...this.knownLinkedFieldNames]) {
      this.fields[fieldName] = UNSET;
    }
  }

  // Directly populate the builder's value for a scalar (Int, String, ID, ...) field. This will fail if the fragment
  // we're configured with doesn't select the field, or if the field is a linked field instead.
  singularScalarFieldSetter(fieldName, value) {
    if (!this.knownScalarFieldNames.has(fieldName)) {
      /* eslint-disable-next-line no-console */
      console.error(
        `Unrecognized scalar field name ${fieldName} in ${this.builderName}\n` +
        `"${fieldName}" may not be included in the GraphQL fragments you passed to this builder.\n` +
        'It may also be present, but as a linked field, in which case the builder definitions should be updated.\n' +
        'Otherwise, try re-running "npm run relay" to regenerate the compiled GraphQL modules.',
      );
      throw new Error(`Unrecognized field name ${fieldName} in ${this.builderName}`);
    }
    this.fields[fieldName] = value;
    return this;
  }

  // Append a scalar value to an Array field. This will fail if the fragment we're configured with doesn't select the
  // field, or if the field is a linked field instead.
  pluralScalarFieldAdder(fieldName, value) {
    if (!this.knownScalarFieldNames.has(fieldName)) {
      /* eslint-disable-next-line no-console */
      console.error(
        `Unrecognized scalar field name ${fieldName} in ${this.builderName}\n` +
        `"${fieldName}" may not be included in the GraphQL fragments you passed to this builder.\n` +
        'It may also be present, but as a linked field, in which case the builder definitions should be updated.\n' +
        'Otherwise, try re-running "npm run relay" to regenerate the compiled GraphQL modules.',
      );
      throw new Error(`Unrecognized field name ${fieldName} in ${this.builderName}`);
    }

    if (this.fields[fieldName] === UNSET) {
      this.fields[fieldName] = [];
    }
    this.fields[fieldName].push(value);

    return this;
  }

  // Build a linked object with a different Builder using "block", then set the field's value based on the builder's
  // output. This will fail if the field is not selected by the current fragment, or if the field is actually a
  // scalar field.
  singularLinkedFieldSetter(fieldName, Builder, block) {
    if (!this.knownLinkedFieldNames.has(fieldName)) {
      /* eslint-disable-next-line no-console */
      console.error(
        `Unrecognized linked field name ${fieldName} in ${this.builderName}.\n` +
        `"${fieldName}" may not be included in the GraphQL fragments you passed to this builder.\n` +
        'It may also be present, but as a scalar field, in which case the builder definitions should be updated.\n' +
        'Otherwise, try re-running "npm run relay" to regenerate the compiled GraphQL modules.',
      );
      throw new Error(`Unrecognized field name ${fieldName} in ${this.builderName}`);
    }

    const Resolved = Builder.resolve();
    const builder = new Resolved(this.spec.getLinkedNodes(fieldName), this.options);
    block(builder);
    this.fields[fieldName] = builder.build();

    return this;
  }

  // Construct a linked object with another Builder using "block", then append the built object to an Array. This will
  // fail if the named field is not selected by the current fragment, or if it's actually a scalar field.
  pluralLinkedFieldAdder(fieldName, Builder, block) {
    if (!this.knownLinkedFieldNames.has(fieldName)) {
      /* eslint-disable-next-line no-console */
      console.error(
        `Unrecognized linked field name ${fieldName} in ${this.builderName}.\n` +
        `"${fieldName}" may not be included in the GraphQL fragments you passed to this builder.\n` +
        'It may also be present, but as a scalar field, in which case the builder definitions should be updated.\n' +
        'Otherwise, try re-running "npm run relay" to regenerate the compiled GraphQL modules.',
      );
      throw new Error(`Unrecognized field name ${fieldName} in ${this.builderName}`);
    }

    if (this.fields[fieldName] === UNSET) {
      this.fields[fieldName] = [];
    }

    const Resolved = Builder.resolve();
    const builder = new Resolved(this.spec.getLinkedNodes(fieldName), this.options);
    block(builder);
    this.fields[fieldName].push(builder.build());

    return this;
  }

  // Explicitly set a field to `null` and prevent it from being populated with a default value. This will fail if the
  // named field is not selected by the current fragment.
  nullField(fieldName) {
    if (!this.knownScalarFieldNames.has(fieldName) && !this.knownLinkedFieldNames.has(fieldName)) {
      /* eslint-disable-next-line no-console */
      console.error(
        `Unrecognized field name ${fieldName} in ${this.builderName}.\n` +
        `"${fieldName}" may not be included in the GraphQL fragments you provided to this builder.\n` +
        'Try re-running "npm run relay" to regenerate the compiled GraphQL modules.',
      );
      throw new Error(`Unrecognized field name ${fieldName} in ${this.builderName}`);
    }

    this.fields[fieldName] = null;
    return this;
  }

  // Finalize any fields selected by the current query that have not been explicitly populated with their default
  // values. Fail if any unpopulated fields have no specified default value or function. Then, return the selected
  // fields as a plain JavaScript object.
  build() {
    const fieldNames = Object.keys(this.fields);

    const missingFieldNames = [];

    const populators = {};
    for (const fieldName of fieldNames) {
      const defaultGetterName = makeDefaultGetterName(fieldName);
      if (this.fields[fieldName] === UNSET && typeof this[defaultGetterName] !== 'function') {
        missingFieldNames.push(fieldName);
        continue;
      }

      Object.defineProperty(populators, fieldName, {
        get: () => {
          if (this.fields[fieldName] !== UNSET) {
            return this.fields[fieldName];
          } else {
            const value = this[defaultGetterName](populators);
            this.fields[fieldName] = value;
            return value;
          }
        },
      });
    }

    if (missingFieldNames.length > 0) {
      /* eslint-disable-next-line no-console */
      console.error(
        `Missing required fields ${missingFieldNames.join(', ')} in builder ${this.builderName}.\n` +
        'Either give these fields a "default" in the builder or call their setters explicitly before calling "build()".',
      );
      throw new Error(`Missing required fields ${missingFieldNames.join(', ')} in builder ${this.builderName}`);
    }

    for (const fieldName of fieldNames) {
      populators[fieldName];
    }

    return this.fields;
  }
}

// Resolve circular references by deferring the loading of a linked Builder class. Create these instances with the
// exported "defer" function.
class DeferredSpecBuilder {
  // Construct a deferred builder that will load a named, exported builder class from a module path. Note that, if
  // modulePath is relative, it should be relative to *this* file.
  constructor(modulePath, className) {
    this.modulePath = modulePath;
    this.className = className;
    this.Class = undefined;
  }

  // Lazily load the requested builder. Fail if the named module doesn't exist, or if it does not export a symbol
  // with the requested class name.
  resolve() {
    if (this.Class === undefined) {
      this.Class = require(this.modulePath)[this.className];
      if (!this.Class) {
        throw new Error(`No class ${this.className} exported from ${this.modulePath}.`);
      }
    }
    return this.Class;
  }
}

// Dynamically construct a Builder class that includes *only* fields that are selected by a GraphQL fragment. Adding
// fields to a fragment will cause them to be automatically included when that a Builder instance is created with
// that fragment; when a field is removed from the fragment, attempting to populate it with a setter method at
// build time will fail with an error.
//
// "typeName" is the name of the GraphQL type from the schema being queried. It will be used to determine which
// fragments to include and to generate a builder name for diagnostic messages.
//
// "fieldDescriptions" is an object detailing the *superset* of the fields used by all fragments on this type. Each
// key is a field name, and its value is an object that controls which methods that are generated on the builder:
//
// * "default" may be a constant value or a function. It's used to populate this field if it has not been explicitly
//   set before build() is called.
// * "linked" names another SpecBuilder class used to build a linked compound object.
// * "plural" specifies that this property is an Array. It implicitly defaults to [] and may be constructed
//   incrementally with an addFieldName() method.
// * "nullable" generates a `nullFieldName()` method that may be used to intentionally omit a field that would normally
//   have a default value.
// * "custom" installs its value as a method on the generated Builder with the provided field name.
//
// See the README in this directory for examples.
export function createSpecBuilderClass(typeName, fieldDescriptions) {
  class Builder extends SpecBuilder {}
  Builder.prototype.typeName = typeName;
  Builder.prototype.builderName = typeName + 'Builder';

  // These functions are used to install functions on the Builder class that implement specific access patterns. They're
  // implemented here as inner functions to avoid the use of function literals within a loop.

  function installScalarSetter(fieldName) {
    Builder.prototype[fieldName] = function(_value) {
      return this.singularScalarFieldSetter(fieldName, _value);
    };
  }

  function installScalarAdder(pluralFieldName, singularFieldName) {
    Builder.prototype[makeAdderFunctionName(singularFieldName)] = function(_value) {
      return this.pluralScalarFieldAdder(pluralFieldName, _value);
    };
  }

  function installLinkedSetter(fieldName, LinkedBuilder) {
    Builder.prototype[fieldName] = function(_block = () => {}) {
      return this.singularLinkedFieldSetter(fieldName, LinkedBuilder, _block);
    };
  }

  function installLinkedAdder(pluralFieldName, singularFieldName, LinkedBuilder) {
    Builder.prototype[makeAdderFunctionName(singularFieldName)] = function(_block = () => {}) {
      return this.pluralLinkedFieldAdder(pluralFieldName, LinkedBuilder, _block);
    };
  }

  function installNullableFunction(fieldName) {
    Builder.prototype[makeNullableFunctionName(fieldName)] = function() {
      return this.nullField(fieldName);
    };
  }

  function installDefaultGetter(fieldName, descriptionDefault) {
    const defaultGetterName = makeDefaultGetterName(fieldName);
    const defaultGetter = typeof descriptionDefault === 'function' ? descriptionDefault : function() {
      return descriptionDefault;
    };
    Builder.prototype[defaultGetterName] = defaultGetter;
  }

  function installDefaultPluralGetter(fieldName) {
    installDefaultGetter(fieldName, function() {
      return [];
    });
  }

  function installDefaultLinkedGetter(fieldName) {
    installDefaultGetter(fieldName, function() {
      this[fieldName]();
      return this.fields[fieldName];
    });
  }

  // Iterate through field descriptions and install requested methods on the Builder class.

  for (const fieldName in fieldDescriptions) {
    const description = fieldDescriptions[fieldName];

    if (description.custom !== undefined) {
      // Custom method. This is a backdoor to let you add random stuff to the final Builder.
      Builder.prototype[fieldName] = description.custom;
      continue;
    }

    const singularFieldName = description.singularName || fieldName;

    // Object.keys() is used to detect the "linked" key here because, in the relatively common case of a circular
    // import dependency, the description will be `{linked: undefined}`, and I want to provide a better error message
    // when that happens.
    if (!Object.keys(description).includes('linked')) {
      // Scalar field.

      if (description.plural) {
        installScalarAdder(fieldName, singularFieldName);
      } else {
        installScalarSetter(fieldName);
      }
    } else {
      // Linked field.

      if (description.linked === undefined) {
        /* eslint-disable-next-line no-console */
        console.error(
          `Linked field ${fieldName} requested without a builder class in ${name}.\n` +
          'This can happen if you have a circular dependency between builders in different ' +
          'modules. Use defer() to defer loading of one builder to break it.',
          fieldDescriptions,
        );
        throw new Error(`Linked field ${fieldName} requested without a builder class in ${name}`);
      }

      if (description.plural) {
        installLinkedAdder(fieldName, singularFieldName, description.linked);
      } else {
        installLinkedSetter(fieldName, description.linked);
      }
    }

    // Install the appropriate default getter method. Explicitly specified defaults take precedence, then plural
    // fields default to [], and linked fields default to calling the linked builder with an empty block to get
    // the sub-builder's defaults.

    if (description.default !== undefined) {
      installDefaultGetter(fieldName, description.default);
    } else if (description.plural) {
      installDefaultPluralGetter(fieldName);
    } else if (description.linked) {
      installDefaultLinkedGetter(fieldName);
    }

    // Install the "explicitly null me out" method.

    if (description.nullable) {
      installNullableFunction(fieldName);
    }
  }

  return Builder;
}

// Resolve circular dependencies among SpecBuilder classes by replacing one of the imports with a defer() call. The
// deferred Builder it returns will lazily require and locate the linked builder at first use.
export function defer(modulePath, className) {
  return new DeferredSpecBuilder(modulePath, className);
}

let theRegistry = null;

// Access the One True spec registry, containing a map of every fragment in the package.
export async function getSpecRegistry() {
  if (theRegistry === null) {
    theRegistry = new SpecRegistry();
  }
  await theRegistry.ensurePopulated();
  return theRegistry;
}
